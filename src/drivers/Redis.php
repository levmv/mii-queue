<?php

namespace mii\queue\drivers;

use Mii;
use mii\queue\Job;
use mii\queue\Queue;
use mii\redis\Redis as RedisConn;

class Redis extends Queue
{
    public string $table = 'queue';

    public string $channel = 'queue';

    public string $component_name = 'redis';

    public RedisConn $redis;

    public function init(array $config = []): void
    {
        parent::init($config); // TODO: Change the autogenerated stub

        $this->redis = Mii::$app->get($this->component_name);
    }


    public function push(Job $job, int $delay = 0)
    {
        $id = $this->redis->incr("$this->channel.message_id");

        $this->redis->hset("$this->channel.messages", $id, $this->serializer->serialize($job));

        if ($delay) {
            $this->redis->zadd("$this->channel.delayed", time() + $delay, $id);
        } else {
            $this->redis->lpush("$this->channel.waiting", $id);
        }

        return $id;
    }


    public function fetch(): ?array
    {
        // Moves delayed and locked jobs into waiting list with lock for one second
        if ($this->redis->set("$this->channel.moving_lock", true, 'NX', 'EX', 1)) {
            $this->moveExpired("$this->channel.delayed");
            $this->moveExpired("$this->channel.locked");
        }

        $result = null;

        // Find a new waiting message
        $id = $this->redis->rpop("$this->channel.waiting");

        if (!$id) {
            return null;
        }

        $job = $this->redis->hget("$this->channel.messages", $id);
        $this->redis->zadd("$this->channel.locked", time() + 300, $id);
        $attempt = $this->redis->hincrby("$this->channel.attempts", $id, 1);

        return [
            'id' => $id,
            'job' => $job,
            'attempt' => $attempt
        ];
    }

    /**
     * @param string $from
     */
    protected function moveExpired($from)
    {
        $now = time();
        if ($expired = $this->redis->zrevrangebyscore($from, $now, '-inf')) {
            $this->redis->zremrangebyscore($from, '-inf', $now);
            foreach ($expired as $id) {
                $this->redis->rpush("$this->channel.waiting", $id);
            }
        }
    }

    public function free($id, int $delay = 0): void
    {
        $this->redis->zadd("$this->channel.delayed", time() + $delay, $id);
    }


    public function remove($id): void
    {
        while (!$this->redis->set("$this->channel.moving_lock", true, 'NX', 'EX', 1)) {
            usleep(10000);
        }
        if ($this->redis->hdel("$this->channel.messages", $id)) {
            $this->redis->zrem("$this->channel.delayed", $id);
            $this->redis->zrem("$this->channel.locked", $id);
            $this->redis->lrem("$this->channel.waiting", 0, $id);
            $this->redis->hdel("$this->channel.attempts", $id);
        }
    }

    public function clear(): void
    {
        while (!$this->redis->set("$this->channel.moving_lock", true, 'NX')) {
            usleep(10000);
        }
        $this->redis->del(...$this->redis->keys("$this->channel.*"));
    }


    public function freeExpired(): void
    {

    }


    public function stat(): array
    {
        return [
            'total' => $this->redis->hlen("$this->channel.messages"),
            'locked' => $this->redis->zcard("$this->channel.locked"),
        ];
    }


    public function status($id): int
    {

        if (!is_numeric($id) || $id <= 0) {
            throw new \InvalidArgumentException("Unknown message ID: $id.");
        }

        if ($this->redis->hexists("$this->channel.attempts", $id)) {
            return self::STATUS_LOCKED;
        }

        if ($this->redis->hexists("$this->channel.messages", $id)) {
            return self::STATUS_WAITING;
        }

        return self::STATUS_DONE;
    }


}
